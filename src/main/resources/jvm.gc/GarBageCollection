参考：https://blog.csdn.net/zhangphil/article/details/78260863
     https://www.jianshu.com/p/5261a62e4d29

观点：
    JVM运行时分区为五部分：Java虚拟机栈、本地方法栈、程序计数器、堆、元数据区
    其中程序计数器、Java虚拟机栈、本地方法栈是线程私有，所申请的内存空间随着线程的终结而亡；
    而元数据区和堆上内存需要管理，gc就是针对堆和元数据区进行内存管理的。

    判断堆内存中对象是否存活方法：
    1.引用计数法
        每个对象都有一个引用计数属性，新增引用+1，释放引用-1，实现简单，判定高效，但是不能解决互相引用的问题。
    2.可达性分析法
        从Gc Root 开始向下所有，所走过的路径为引用链，但没有一个引用链能与Gc Root相连，则对象引用为0

    Java Gc算法：
    1.标记-清除
        分标记和清除两个阶段，首先标记需要回收的对象，当标记完成后，进行统一清除。
        效率不高，且易产生大量空间碎片。
    2.复制算法
        将内存等量分为两部分，将一块内存用完后，将还存活的对象复制到另一块，然后对其进行清除。
        代价是内存空间减少一半，持续复制长期存活的对象，降低效率。

    Java Gc分代垃圾回收机制：
    将堆分为两部分：老年代和新生代， 新生代对象存活比例小，采用复制算法。老年代存活比例大，采用标记-清理算法。

    Java Gc由两种情况触发：
    1.大部分对象很快变得不可达。
    2.只有很少的老对象指向新对象的引用。

    Java Gc优化：
        将"stop the world"， jvm应为要执行gc而停止了应用程序 的执行，除了gc所需要的线程外，其他线程都要处于等待状态。
        优化即减少stop the world发生的时间，即减少创建对象的数量。
